{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "unit_test_tour",
  "steps": [
    {
      "file": "unit_tests/bank_account.py",
      "description": "The BankAccount class will be the subject of our Unit Testing. \nIt contains methods for depositing, withdrawing, and getting the balance of an account.\n",
      "line": 1
    },
    {
      "file": "unit_tests/test_bank_account.py",
      "description": "You can prompt Copilot with a request to write tests that cover a range of scenarios. Be specific with your test requirements to get the best results. The following is an example prompt you can use to generate unit tests for the BankAccount class.\n\nCtrl + I to bring up the inline chat!\n\nPrompt:\n> Develop a comprehensive suite of unit tests for the BankAccount() function in Python. Write multiple test methods that cover a wide range of scenarios, including edge cases, exception handling, and data validation.",
      "line": 4
    },
    {
      "file": "unit_tests/test_bank_account.py",
      "description": "The test suite generated by Copilot includes a test case for each scenario specified in the prompt. Each function in the BankAccount class is tested for a range of conditions, including valid operations like deposits and withdrawals, as well as edge cases such as negative amounts and attempts to withdraw more than the available balance.\n\nYou can ask it how to run the tests.\n\nPrompt:\n> \"How do I run these unit tests in Python using the unittest framework?\"\n\nIt will give you the following command:\n```\npython -m unittest test_bank_account.py\n```",
      "line": 37
    },
    {
      "file": "unit_tests/test_bank_account.py",
      "description": "Additionally, you can prompt Copilot to write a full suite of unit tests with the ``` /tests ``` slash command. Ensure that you have the file open on the current tab of your IDE and Copilot will generate unit tests for that file. The tests that Copilot generates may not cover all scenarios, so you should always review the generated code and add any additional tests that may be necessary.\n\n\n\n> TIP: If you ask Copilot to write tests for a code file that is not already covered by unit tests, you can provide Copilot with useful context by opening one or more existing test files in adjacent tabs in your editor. Copilot will be able to see the testing framework you use and will be more likely to write a test that is consistent with your existing tests.",
      "line": 41
    },
    {
      "file": "unit_tests/updated_bank_account.py",
      "description": "Integration tests are essential for ensuring that the various components of your system work correctly when combined. In this section, we’ll extend our ```BankAccount``` class to include interactions with an external service NotificationSystem and use mocks to test the system’s behavior without needing real connections. The goal of the integration tests is to verify the interaction between the BankAccount class and the NotificationSystem services, ensuring that they work together correctly.\n\nLet's update the BankAccount class to include interactions with an external service such as a NotificationSystem that sends notifications to users. NotificationSystem represents the integration that would need to be tested.",
      "line": 1
    },
    {
      "file": "unit_tests/test_updated_bank_account.py",
      "description": "Here we'll break down our request for Copilot to write integration tests for the BankAccount class into smaller, more manageable pieces. This will help Copilot generate more accurate and relevant tests.\nPrompt:\n> \"Write integration tests for the deposit function in the BankAccount class. Use mocks to simulate the NotificationSystem and verify that it is called correctly after a deposit.\"",
      "line": 5
    },
    {
      "file": "unit_tests/test_updated_bank_account.py",
      "description": "The prompt above generated a single test case that verifies the NotificationSystem is called when a valid deposit is made. However, it doesn't cover cases where an error is raised during the deposit. In those scenarios, the NotificationSystem should not be called. We need to add a test case that handles invalid deposits and ensure the notification system is not triggered.\n\nPrompt: \n> \"Add a test case for invalid deposit amounts to verify the function raises the correct exceptions and that the NotificationService is not called.\"\n\nA test case similar to this will be generated:\n```\n    def test_deposit_negative_amount_raises_error(self):\n        account = BankAccount(initial_balance=100, notification_system=self.notification_system)\n        with self.assertRaises(ValueError):\n            account.deposit(0)\n        self.notification_system.notify.assert_not_called()\n```",
      "line": 6
    }
  ]
}